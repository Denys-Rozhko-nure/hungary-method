// Імпортуємо бібліотеку React задля корректної роботи рендерингу
import React, { useState } from "react";
// Імпортуємо нашу функцію, котра вирішує задачу про призначення
// Угорським методом та повертає усі проміжні стани
import getStates from "./getStates"

// Створюєму приклад параметрів задачі про призначення
const exampleC = [
  [ 1,  8,  5],
  [10, 11, 34],
  [ 9,  1,  2]
];

// Створюємо початковий стан
const initialState = {

  // Початкова матриця параметрів часу
  c: [],
  // Початковий масив, що відповідає за позначення рядків
  // Якщо і-й елемент масиву містить true, то відповідний рядок позначений зірочкої
  // Інакше - не позначений
  markedRows: [false, false, false],

  // Аналогічно з позначенням стовпців
  markedColumns: [false, false, false]
};

// Масив збережниз значеннь параметрів часу
// Це зроблено тому, що відповідний масив у змінній стану
// Ми будемо у подальшому змінювати
const savedC = [];

// Наш компонент, що повертає розмітку програми
function App() {

  // useState - функція із React, що дозволяє реактивно змінювати значення змінних
  // У функції ми завжди отримуємо поточне значенн змінної (states i finalMessage)
  // Встановлюємо ми значення через особливу функцію(наступну після змінної), що встановлює
  // актуальне значення і запускає перемальовку розмітки з уже актуальними даними
  const [states, setStates] = useState([]);
  const [finalMessage, setFinalMessage] = useState("");

  // Сворюємо функції створення розмітки для клітинок вводу значень матриці
  // Зроблено це задля зручності і відсутності дублюючогося коду
  const cInput = (i, j) => (<input 
    type="number" 

    // У таких `` кавичках - шабланні строки. Вони підставляюсть значення з ${} у строку
    // Наприклад `с${i}${j}` при i = 1 та j = 6 буде "a16"
    id={`c${i}${j}`} 
    step="0.01" 

    // У таких фігурних дужках вставляються не статичні значення, як у HTML
    // А динамічні, як у JSX
    defaultValue={exampleC[i][j]}
  />);

  // Функція початку обчисленнь
  function startCalculate() {

    // Ітеруємося по рядкам матриці С
    for(let i = 0; i < initialState.markedRows.length; ++i) {
      // Додаємо у матрицю С рядок
      // Відповідно до матриці збереженої окремо та до змінної початкового стану
      savedC.push([]);
      initialState.c.push([])

      // Ітеруємося по стовпцям матриці С
      for(let j = 0; j < initialState.markedColumns.length; ++j) {
        // Знаходимо відповідальний за цю клітинку HTML-елемент
        const el = document.getElementById(`c${i}${j}`);
        // Беремо його значення
        const val = el.valueAsNumber;

        // Додаємо його до поточного рядку матриці
        savedC[i].push(val);
        initialState.c[i].push(val);
      }
    }

    // Отримуємо масив проміжних станів
    const states = getStates(initialState);

    // Беремо матрицю С фінального стану
    const c = states[states.length - 1].c;
    // Ініціалізуємо сумму часових витрат нулем
    let sum = 0;

    // Ітеруємося по клітинкам матриці
    for(let i = 0; i < c.length; ++i) {
      for(let j = 0; j < c[i].length; ++j) {

        // Якщо у цій матриці елемент дорівнює нулю
        // То він включений у розв'язок
        // Тому додаємо до часових витрат значення цієї клітинки у початковій матриці
        if(c[i][j] === 0) 
          sum += savedC[i][j];
      }
    }

    // Встановлюємо фінальне повідомлення про розв'язок задачі
    setFinalMessage(`Фінальний мінімальний час виконання усіх робіт складає ${sum} хв`);
    // Встановлюємо масив станів
    setStates(states);
  }

  // Тут ми повертаємо увесь JSX код.
  // Зазвичай він відповідає HTML кодові, тому коментувати будемо лише окремі моменти
  return (
    <>
      <h3>Уведіть свої дані у таблицю нижче і натисніть "Розрахувати"</h3>

      <table>
        <thead>
          <tr>
            <th></th>
            <th>Верстат<sub>1</sub></th>
            <th>Верстат<sub>2</sub></th>
            <th>Верстат<sub>3</sub></th>
          </tr>
        </thead>
        <tbody>
          {/* Коментарі тут пишуться так, а не через "//", як у джаваскрипт  */}
      
          {/* Конструкція з фігурних скобок означає, що ми щось динамічно вписуємо
              Нижче, ми беремо масив і для кожного з його елементів повераємо JSX розмітку
              Це створено для рендерингу списку однотипних елементів
              У даному випадку усі, окрім верхньої рядки таблиці 
          */}

          {[0, 1, 2].map(i =>
            <tr key={i}>
              <td>Робота<sub>{i+1}</sub></td>
              {[0, 1, 2].map(j =>
                <td key={j}>c<sub>{i+1}{j+1}</sub> = {cInput(i, j)}</td>
              )}
            </tr>
          )}
        </tbody>
      </table>

     {/*Тут кнопці "Розрахувати" ми визначаємо, що функція початку обчислень
     буде запускатися при кліці на кнопку через задання аргументу
     onClick
    */}

    <button onClick={startCalculate} >Розрахувати</button>

    {/*className у JSX - аналог class у HTML*/}
    <div className="finalMessage">{finalMessage}</div>

    {states.map(state =>
      <table>
        <tbody>
          <tr>
            <td></td>
            <td>Верстат<sub>1</sub></td>
            <td>Верстат<sub>2</sub></td>
            <td>Верстат<sub>3</sub></td>
            <td></td>
          </tr>

          {state.c.map((row, i) =>
            <tr>
              <td>Робота<sub>{i+1}</sub></td>
              {[0, 1, 2].map(j => 
                <td>
                  {/*
                    Тут ми використовуємо тернарний оператор для умовного рендерингу
                  */}
                  {state.c[i][j] === null ?
                    <strike>0</strike> :
                    state.c[i][j] === 0 ?
                      <span className="green">0</span> :
                      state.c[i][j]
                  }
                </td>
              )}
              <td>
                {/*
                  Тут ми за умови state.markedRows[i] === true повертаємо символьний рядок "*"
                */}
                {state.markedRows[i] && "*"}
              </td>
            </tr>
          )}

          <tr>
            <td></td>
            {[0, 1, 2].map(j =>
              <td>
                {state.markedColumns[j] && "*"}
              </td>
            )}
          </tr>

        </tbody>
      </table>
    )}

    </>
  );
}

// Експортуємо наш елемент
export default App;
